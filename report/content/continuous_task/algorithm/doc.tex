\subsection{Численный синтез управления}

Приведем алгоритм для построения управления.
Мы будем строить кусоч\-но-постоянное управление на сетке с мелким шагом, как минимум меньшим, чем величина запаздывания.
Такой способ не идеален: основная ошибка будет накапливаться не только за счет интегрирования, а в первую очередь из-за выбора класса управления, никак не учтенного в теории.
С другой стороны при стремлении шага разбиения к нулю численное решение, построенное по предложенному алгоритму, будет приближено к теоретическому результату.
\begin{enumerate}
        \item Введём на отрезке времени $[t_0,\,t_1]$ равномерное разбиение с шагом $\varepsilon$:
$$
        \{t^k\}_{k=1}^{N},\mbox{ где }
        t_0 = t^1 < t^2 <\ldots<t^N \leqslant t_1,
        \quad t^{k+1} - t^k = \varepsilon,
        \quad t_1 - t^N < \varepsilon.
$$
        \item Численно решим уравнение \eqref{eq:rikkati} и запомним получившиеся значения
$$
        P^k = P(t^k),
        \quad\mbox{где } k = \overline{1,N}.
$$
        \item На каждом участке $[t^k,\,t^{k+1}]$ будем численно строить постоянное управление $u^k$ по формуле \eqref{eq:opt_control} и запоминать его. Здесь мы будем использовать посчитанную ранее $P^k$, а величину запаздывания наблюдения увеличим до $\tilde h = \left\lceil\frac{h}{\varepsilon}\right\rceil\varepsilon$.

        \item Решим систему \eqref{eq:first_task} для построенного управления $u^k$ на отрезке $[t^k,\,t^{k+1}]$ и запомним финальное состояние $x(t^{k+1})$.
\end{enumerate}