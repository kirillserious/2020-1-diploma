\section{Численный синтез управления}

Приведем алгоритм для построения управления. Мы будем строить кусочно-постоянное управление на сетке с мелким шагом, как минимум меньшим, чем величина запаздывания. Такой способ не идеален: основная ошибка будет накапливаться не только за счет интегрирования, а в первую очередь из-за выбора класса управления, никак не учтенного в теории. С другой стороны кусочно-постоянные управления чаще встречаются в существующих реальных системах и, при стремлении шага разбиения к нулю, численный алгоритм приближен к теоретическому результату.
\begin{enumerate}
        \item Введём на отрезке времени $[t_0,\,t_1]$ равномерное разбиение с шагом $\varepsilon$:
$$
        \{t^k\}_{k=1}^{N},\mbox{ где }
        t_0 = t^1 < t^2 <\ldots<t^N \leqslant t_1,
        \quad t^{k+1} - t^k = \varepsilon,
        \quad t_1 - t^N < \varepsilon.
$$
        \item На каждом участке $[t^k,\,t^{k+1}]$ будем численно строить постоянное управление по формуле \eqref{eq:opt_control}. Причем запаздывание наблюдения увеличим до величины $\tilde h = \left\lceil\frac{h}{\varepsilon}\right\rceil\varepsilon$.
        \item Решим систему \eqref{eq:first_task} для построенного управления на отрезке $[t^k,\,t^{k+1}]$ и запомним финальное состояние $x(t^{k+1})$.
\end{enumerate}

Такое разбиение также моделирует невозможность реальных систем непрерывно передавать данные о своем состоянии. Если мы рассматриваем такие системы, то величину $\varepsilon$ можно интерпретировать как время между двумя отправками данных. Тогда мы можем провести численные эксперименты поведения посторенного решения при увеличении этого времени.